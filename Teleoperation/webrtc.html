<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    body, html {
      height: 100vh;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #2a2a2a;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }
    
    #main-container {
      display: flex;
      height: 100vh;
      flex-direction: row;
    }
    
    /* Video section takes most of the space */
    #video-section {
      flex: 1;
      position: relative;
      background: #000;
      min-width: 0; /* Important for flexbox */
    }
    
    /* Container for the video to allow an overlay */
    #video-container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* The video fits within the container while maintaining aspect ratio */
    #video {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
      display: block;
    }
    
    /* Overlay container for controls on top of the video, positioned at top-left */
    #video-controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      z-index: 1000;
    }
    #video-controls button {
      margin: 5px;
      padding: 5px 10px;
      background: rgba(255, 255, 255, 0.3);
      border: none;
      color: #fff;
      cursor: pointer;
      border-radius: 3px;
    }
    #video-controls button:hover {
      background: rgba(255, 255, 255, 0.5);
    }
    #video-controls button.active {
      background: rgba(255, 255, 255, 0.6);
    }
    
    /* Debug Panel section on the right side */
    #chat-section {
      width: 380px;
      background: #f5f5f5;
      border-left: 2px solid #ddd;
      display: flex;
      flex-direction: column;
      min-width: 0;
      transition: width 0.3s ease;
    }
    
    #chat-section.hidden {
      width: 0;
      border-left: none;
      overflow: hidden;
    }
    
    #chat-header {
      background: #2c3e50;
      padding: 10px 12px;
      border-bottom: 1px solid #34495e;
      font-weight: bold;
      color: #ecf0f1;
      font-size: 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    #chat-toggle {
      background: #e74c3c;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
      font-weight: bold;
      transition: background 0.2s;
    }
    
    #chat-toggle:hover {
      background: #c0392b;
    }
    
    /* Floating toggle button when debug panel is hidden */
    #floating-chat-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #3498db;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      z-index: 2000;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
    }
    
    #floating-chat-toggle:hover {
      background: #2980b9;
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    }
    
    #floating-chat-toggle.hidden {
      display: none;
    }
    
    #chat-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      overflow-x: hidden;
    }
    
    #chat-content::-webkit-scrollbar {
      width: 8px;
    }
    
    #chat-content::-webkit-scrollbar-track {
      background: #f1f1f1;
    }
    
    #chat-content::-webkit-scrollbar-thumb {
      background: #bdc3c7;
      border-radius: 4px;
    }
    
    #chat-content::-webkit-scrollbar-thumb:hover {
      background: #95a5a6;
    }
    
    /* Control String Display */
    .debug-section {
      background: #fff;
      margin: 10px;
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #ddd;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    .debug-section-title {
      font-weight: bold;
      font-size: 13px;
      color: #2c3e50;
      margin-bottom: 8px;
      padding-bottom: 5px;
      border-bottom: 2px solid #3498db;
    }
    
    #control-string {
      background: #ecf0f1;
      border: 1px solid #bdc3c7;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      padding: 8px;
      font-size: 11px;
      color: #2c3e50;
      max-height: 80px;
      overflow-y: auto;
      word-wrap: break-word;
      word-break: break-all;
      white-space: pre-wrap;
    }
    
    /* Tuning Controls */
    .tuning-control {
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid #ecf0f1;
    }
    
    .tuning-control:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }
    
    .tuning-label {
      font-size: 12px;
      font-weight: 600;
      color: #34495e;
      margin-bottom: 5px;
      display: block;
    }
    
    .tuning-description {
      font-size: 10px;
      color: #7f8c8d;
      margin-bottom: 5px;
      font-style: italic;
    }
    
    .tuning-input-group {
      display: flex;
      gap: 5px;
      align-items: center;
    }
    
    .tuning-input {
      flex: 1;
      padding: 6px 8px;
      border: 1px solid #bdc3c7;
      border-radius: 3px;
      font-size: 12px;
      font-family: 'Courier New', monospace;
      background: #fff;
    }
    
    .tuning-input:focus {
      outline: none;
      border-color: #3498db;
      box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
    }
    
    .tuning-btn {
      padding: 6px 12px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
      font-weight: bold;
      transition: all 0.2s;
      white-space: nowrap;
    }
    
    .tuning-btn:hover {
      background: #2980b9;
      transform: translateY(-1px);
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    
    .tuning-btn:active {
      transform: translateY(0);
    }
    
    .tuning-btn.special {
      background: #e74c3c;
    }
    
    .tuning-btn.special:hover {
      background: #c0392b;
    }
    
    /* Toggle switch for boolean values */
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
      flex-shrink: 0;
    }
    
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #95a5a6;
      transition: 0.3s;
      border-radius: 24px;
    }
    
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }
    
    input:checked + .toggle-slider {
      background-color: #27ae60;
    }
    
    input:checked + .toggle-slider:before {
      transform: translateX(20px);
    }
    
    .toggle-label {
      font-size: 11px;
      color: #7f8c8d;
      margin-left: 5px;
    }
  </style>
</head>
<body>
  <div id="main-container">
    <!-- Video Section -->
    <div id="video-section">
      <div id="video-container">
        <video id="video" autoplay playsinline></video>
        <div id="video-controls">
          <button id="start-button">Click to Start and Enable Audio</button>
          <button id="mute-button" style="display:none;">Mute</button>
        </div>
      </div>
    </div>
    
    <!-- Debug Panel Section -->
    <div id="chat-section">
      <div id="chat-header">
        <span>üîß Actuator Debug Panel</span>
        <button id="chat-toggle">Hide</button>
      </div>
      <div id="chat-content">
        <!-- Current Control String Display -->
        <div class="debug-section">
          <div class="debug-section-title">üì° Current Control String</div>
          <div id="control-string"></div>
        </div>
        
        <!-- Tuning Commands Section -->
        <div class="debug-section">
          <div class="debug-section-title">‚öôÔ∏è Actuator Tuning</div>
          
          <!-- Actuator Selection and Retrieve -->
          <div class="tuning-control" style="background: #e8f4f8; padding: 10px; border-radius: 5px; margin-bottom: 15px;">
            <label class="tuning-label">üì° Select Actuator</label>
            <div class="tuning-description">Choose actuator to configure (decimal address)</div>
            <div class="tuning-input-group">
              <select id="actuator-id-select" class="tuning-input" style="flex: 2;">
                <optgroup label="Wheel Actuators">
                  <option value="512">Wheel Actuator 1 (0x200 / 512)</option>
                  <option value="768">Wheel Actuator 2 (0x300 / 768)</option>
                </optgroup>
                <optgroup label="Neck Actuator">
                  <option value="1280">Neck Actuator (0x500 / 1280)</option>
                </optgroup>
                <optgroup label="Joint Actuators (Arm)">
                  <option value="1536">Joint 1 (0x600 / 1536)</option>
                  <option value="1537">Joint 2 (0x601 / 1537)</option>
                  <option value="1538">Joint 3 (0x602 / 1538)</option>
                  <option value="1539">Joint 4 (0x603 / 1539)</option>
                  <option value="1540">Joint 5 (0x604 / 1540)</option>
                  <option value="1541">Joint 6 (0x605 / 1541)</option>
                  <option value="1542">Joint 7 (0x606 / 1542)</option>
                  <option value="1543">Joint 8 (0x607 / 1543)</option>
                  <option value="1544">Joint 9 (0x608 / 1544)</option>
                  <option value="1545">Joint 10 (0x609 / 1545)</option>
                  <option value="1546">Joint 11 (0x60A / 1546)</option>
                  <option value="1547">Joint 12 (0x60B / 1547)</option>
                </optgroup>
                <optgroup label="Broadcast">
                  <option value="65535">All Actuators (0xFFFF)</option>
                </optgroup>
              </select>
              <button class="tuning-btn" onclick="retrieveTelemetry()" style="background: #27ae60;">üì• Retrieve</button>
            </div>
            <div id="telemetry-status" style="font-size: 10px; color: #7f8c8d; margin-top: 5px; font-style: italic;">
              Click "Retrieve" to load current values from actuator
            </div>
          </div>
          
          <!-- CAN Address -->
          <div class="tuning-control">
            <label class="tuning-label">CAN Address</label>
            <div class="tuning-description">Set device CAN address (decimal, e.g., 512 for 0x200)</div>
            <div class="tuning-input-group">
              <input type="number" id="tune-address" class="tuning-input" placeholder="512" min="0" max="2047" step="1">
              <button class="tuning-btn" onclick="sendTuningCommand('tune_address', 'number')">Send</button>
            </div>
          </div>
          
          <!-- Actuator Setpoint -->
          <div class="tuning-control">
            <label class="tuning-label">Actuator Setpoint</label>
            <div class="tuning-description">Zero position offset in degrees</div>
            <div class="tuning-input-group">
              <input type="number" id="tune-setpoint" class="tuning-input" placeholder="0.0" step="0.1" min="-360" max="360">
              <button class="tuning-btn" onclick="sendTuningCommand('tune_setpoint', 'float')">Send</button>
            </div>
          </div>
          
          <!-- Motor Direction -->
          <div class="tuning-control">
            <label class="tuning-label">Motor Direction</label>
            <div class="tuning-description">Invert motor direction</div>
            <div class="tuning-input-group">
              <label class="toggle-switch">
                <input type="checkbox" id="tune-motor-dir">
                <span class="toggle-slider"></span>
              </label>
              <span class="toggle-label" id="motor-dir-label">Normal</span>
              <button class="tuning-btn" onclick="sendTuningCommand('tune_motor_dir', 'boolean')">Send</button>
            </div>
          </div>
          
          <!-- Sensor Direction -->
          <div class="tuning-control">
            <label class="tuning-label">Sensor Direction</label>
            <div class="tuning-description">Invert sensor count direction</div>
            <div class="tuning-input-group">
              <label class="toggle-switch">
                <input type="checkbox" id="tune-sensor-dir">
                <span class="toggle-slider"></span>
              </label>
              <span class="toggle-label" id="sensor-dir-label">Normal</span>
              <button class="tuning-btn" onclick="sendTuningCommand('tune_sensor_dir', 'boolean')">Send</button>
            </div>
          </div>
          
          <!-- P Gain -->
          <div class="tuning-control">
            <label class="tuning-label">P Gain</label>
            <div class="tuning-description">Proportional gain value (3.0-10.0 typical)</div>
            <div class="tuning-input-group">
              <input type="number" id="tune-p" class="tuning-input" placeholder="5.0" step="0.1" min="0" max="100">
              <button class="tuning-btn" onclick="sendTuningCommand('tune_p', 'float')">Send</button>
            </div>
          </div>
          
          <!-- Max PWM -->
          <div class="tuning-control">
            <label class="tuning-label">Maximum PWM</label>
            <div class="tuning-description">Maximum PWM value (0-255)</div>
            <div class="tuning-input-group">
              <input type="number" id="tune-max-pwm" class="tuning-input" placeholder="255" min="0" max="255" step="5">
              <button class="tuning-btn" onclick="sendTuningCommand('tune_max_pwm', 'number')">Send</button>
            </div>
          </div>
          
          <!-- Min PWM -->
          <div class="tuning-control">
            <label class="tuning-label">Minimum PWM (Deadzone)</label>
            <div class="tuning-description">Minimum PWM value (0-255, typically 30-40)</div>
            <div class="tuning-input-group">
              <input type="number" id="tune-min-pwm" class="tuning-input" placeholder="30" min="0" max="255" step="5">
              <button class="tuning-btn" onclick="sendTuningCommand('tune_min_pwm', 'number')">Send</button>
            </div>
          </div>
          
          <!-- Save Parameters -->
          <div class="tuning-control">
            <label class="tuning-label">Save to EEPROM</label>
            <div class="tuning-description">Persist current parameters to ESP32 flash memory</div>
            <div class="tuning-input-group">
              <button class="tuning-btn special" onclick="sendTuningCommand('tune_save', 'save')" style="flex: 1;">üíæ Save Parameters</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Floating toggle button for when debug panel is hidden -->
  <button id="floating-chat-toggle" class="hidden">Show Debug Panel</button>
  
  <audio id="audio" autoplay playsinline muted style="display:none;"></audio>
  
  <script>
    // Global variable to hold the current WebSocket.
    let globalWS = null;
    let currentPC = null;

    function startSignaling() {
      // Create a new peer connection.
      currentPC = new RTCPeerConnection();

      const ws = new WebSocket("ws://64.225.55.176:8080");
      globalWS = ws;

      ws.onopen = () => {
        console.log("DEBUG: Browser connected to signaling server");
      };

      ws.onmessage = async (event) => {
        const data = JSON.parse(event.data);
        console.log("DEBUG: Browser received", data);
        console.log("DEBUG: Message type:", data.type);
        if (data.type === "offer") {
          console.log("DEBUG: Received offer, setting remote description");
          await currentPC.setRemoteDescription({ type: "offer", sdp: data.sdp });
          const answer = await currentPC.createAnswer();
          await currentPC.setLocalDescription(answer);
          console.log("DEBUG: Sending answer");
          ws.send(JSON.stringify({
            type: "answer",
            sdp: answer.sdp
          }));
        } else if (data.type === "candidate") {
          try {
            console.log("DEBUG: Adding ICE candidate", data.candidate);
            await currentPC.addIceCandidate(data.candidate);
          } catch (err) {
            console.error("DEBUG: Error adding candidate", err);
          }
        } else if (data.type === "control") {
          // Control messages are logged but not displayed (we show outgoing only)
          console.log("DEBUG: Received control message:", data);
        } else if (data.type === "telemetry") {
          // Handle telemetry data from actuator
          console.log("DEBUG: Received telemetry:", data.data);
          console.log("DEBUG: Telemetry data type:", typeof data.data);
          console.log("DEBUG: Telemetry data keys:", Object.keys(data.data));
          handleTelemetry(data.data);
        }
      };

      ws.onclose = () => {
        console.log("DEBUG: WebSocket closed. Reconnecting in 5 seconds...");
        // Clean up the old peer connection.
        if (currentPC) {
          currentPC.close();
          currentPC = null;
        }
        setTimeout(startSignaling, 5000);
      };

      ws.onerror = (err) => {
        console.error("DEBUG: WebSocket error", err);
        ws.close();
      };

      currentPC.onicecandidate = (event) => {
        if (event.candidate) {
          const candidateMsg = JSON.stringify({
            type: "candidate",
            candidate: event.candidate
          });
          console.log("DEBUG: Sending ICE candidate", candidateMsg);
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(candidateMsg);
          }
        }
      };

      currentPC.ontrack = (event) => {
        event.streams.forEach((stream) => {
          if (stream.getVideoTracks().length > 0) {
            const video = document.getElementById("video");
            if (video.srcObject !== stream) {
              video.srcObject = stream;
              console.log("DEBUG: Attached video stream.");
            }
          }
          if (stream.getAudioTracks().length > 0) {
            const audioElement = document.getElementById("audio");
            if (audioElement.srcObject !== stream) {
              audioElement.srcObject = stream;
              console.log("DEBUG: Attached audio stream.");
            }
          }
        });
      };
    }

    // Start the signaling process immediately.
    startSignaling();

    // --- Control String and Audio Button Code ---
    const audioElement = document.getElementById("audio");
    const startButton = document.getElementById("start-button");
    startButton.addEventListener("click", () => {
      const video = document.getElementById("video");
      video.muted = false;
      audioElement.muted = false;
      video.play().then(() => {
        console.log("DEBUG: Video playback started with audio enabled.");
      }).catch((err) => {
        console.error("DEBUG: Error starting video playback:", err);
      });
      audioElement.play().then(() => {
        console.log("DEBUG: Audio playback initiated by user gesture.");
      }).catch(err => {
        console.error("DEBUG: Error initiating audio playback:", err);
      });
      startButton.style.display = "none";
      document.getElementById("mute-button").style.display = "inline-block";
    });
    
    const muteButton = document.getElementById("mute-button");
    muteButton.addEventListener("click", () => {
      const video = document.getElementById("video");
      if(video.muted) {
        video.muted = false;
        audioElement.muted = false;
        muteButton.textContent = "Mute";
      } else {
        video.muted = true;
        audioElement.muted = true;
        muteButton.textContent = "Unmute";
      }
    });

    // --- Control String Functionality ---
    const defaultFixedPart = "mac=asda;h1X=0;h1Y=0;h1Z=0;h1p=0;h1y=0;h1r=0;h2X=0;h2Y=0;h2Z=0;h2p=0;h2y=0;h2r=0;";
    let baseControlString = "";
    let controlState = { f: 0, b: 0, l: 0, r: 0, u: 0, d: 0 };

    function getControlString() {
      const base = baseControlString || defaultFixedPart;
      return base;
    }

    function updateControlDisplay() {
      const controlStr = getControlString();
      const controlDisplay = document.getElementById("control-string");
      const timestamp = new Date().toLocaleTimeString();
      
      // Show the current control string being sent
      controlDisplay.textContent = `[${timestamp}] ${controlStr}`;
    }

    function sendControlString() {
      const controlStr = getControlString();
      // Send only if the current WebSocket exists and is open.
      if (globalWS && globalWS.readyState === WebSocket.OPEN) {
        globalWS.send(JSON.stringify({ type: "control", controlString: controlStr }));
        console.log("DEBUG: Sent control string:", controlStr);
      }
    }

    function setControl(key, value) {
      controlState[key] = value;
      updateControlDisplay();
      sendControlString();
    }

    updateControlDisplay();

    window.addEventListener("message", (event) => {
      if (event.data && event.data.controlString) {
        baseControlString = event.data.controlString;
        updateControlDisplay();
        console.log("DEBUG: Received updated control string via postMessage:", getControlString());
      }
    });

    // Send out the control string at 20 Hz (every 50 ms)
    setInterval(sendControlString, 50);
    
    // Debug panel toggle functionality
    function toggleChat() {
      const chatSection = document.getElementById('chat-section');
      const toggleButton = document.getElementById('chat-toggle');
      const floatingToggle = document.getElementById('floating-chat-toggle');
      
      chatSection.classList.toggle('hidden');
      
      if (chatSection.classList.contains('hidden')) {
        toggleButton.textContent = 'Show';
        floatingToggle.classList.remove('hidden');
      } else {
        toggleButton.textContent = 'Hide';
        floatingToggle.classList.add('hidden');
      }
    }
    
    // Add event listeners for both toggle buttons
    document.getElementById('chat-toggle').addEventListener('click', toggleChat);
    document.getElementById('floating-chat-toggle').addEventListener('click', toggleChat);
    
    // Update toggle labels when checkboxes change
    document.getElementById('tune-motor-dir').addEventListener('change', function() {
      document.getElementById('motor-dir-label').textContent = this.checked ? 'Inverted' : 'Normal';
    });
    
    document.getElementById('tune-sensor-dir').addEventListener('change', function() {
      document.getElementById('sensor-dir-label').textContent = this.checked ? 'Inverted' : 'Normal';
    });
    
    // Function to send tuning commands
    function sendTuningCommand(commandKey, valueType) {
      let value;
      let inputId;
      
      // Get the value based on command type
      switch(commandKey) {
        case 'tune_address':
          inputId = 'tune-address';
          break;
        case 'tune_setpoint':
          inputId = 'tune-setpoint';
          break;
        case 'tune_motor_dir':
          inputId = 'tune-motor-dir';
          break;
        case 'tune_sensor_dir':
          inputId = 'tune-sensor-dir';
          break;
        case 'tune_p':
          inputId = 'tune-p';
          break;
        case 'tune_max_pwm':
          inputId = 'tune-max-pwm';
          break;
        case 'tune_min_pwm':
          inputId = 'tune-min-pwm';
          break;
        case 'tune_save':
          value = 1;
          break;
      }
      
      // Get value from input
      if (inputId) {
        const input = document.getElementById(inputId);
        if (valueType === 'boolean') {
          value = input.checked ? 1 : 0;
        } else if (valueType === 'float') {
          value = parseFloat(input.value);
          if (isNaN(value)) {
            alert('Please enter a valid number');
            return;
          }
        } else if (valueType === 'number') {
          value = parseInt(input.value);
          if (isNaN(value)) {
            alert('Please enter a valid number');
            return;
          }
        } else {
          value = input.value;
        }
      }
      
      // Construct command string
      const commandString = `${commandKey}=${value}`;
      
      // Send the command
      if (globalWS && globalWS.readyState === WebSocket.OPEN) {
        globalWS.send(JSON.stringify({ 
          type: "control", 
          controlString: commandString 
        }));
        
        console.log(`‚úÖ Sent tuning command: ${commandString}`);
        
        // Visual feedback - flash the button
        const btn = event.target;
        const originalBg = btn.style.backgroundColor;
        btn.style.backgroundColor = '#27ae60';
        btn.textContent = '‚úì Sent';
        setTimeout(() => {
          btn.style.backgroundColor = originalBg;
          btn.textContent = 'Send';
        }, 1000);
        
        // Update control string display to show what was sent
        const controlDisplay = document.getElementById('control-string');
        const timestamp = new Date().toLocaleTimeString();
        controlDisplay.textContent = `[${timestamp}] ${commandString}\n` + controlDisplay.textContent;
        
      } else {
        alert('WebSocket not connected!');
        console.error('Cannot send tuning command: WebSocket not connected');
      }
    }
    
    // Function to request telemetry from actuator
    function retrieveTelemetry() {
      const actuatorId = document.getElementById('actuator-id-select').value;
      const statusDiv = document.getElementById('telemetry-status');
      
      if (globalWS && globalWS.readyState === WebSocket.OPEN) {
        // Send telemetry request command
        const commandString = `tune_request_telemetry=${actuatorId}`;
        globalWS.send(JSON.stringify({ 
          type: "control", 
          controlString: commandString 
        }));
        
        console.log(`‚úÖ Requested telemetry from actuator ${actuatorId}`);
        statusDiv.textContent = `‚è≥ Requesting telemetry from actuator ${actuatorId}...`;
        statusDiv.style.color = '#3498db';
        
        // Set timeout in case no response
        setTimeout(() => {
          if (statusDiv.textContent.includes('Requesting')) {
            statusDiv.textContent = '‚ö†Ô∏è No response from actuator. Check connection.';
            statusDiv.style.color = '#e74c3c';
          }
        }, 3000);
        
      } else {
        alert('WebSocket not connected!');
        statusDiv.textContent = '‚ùå WebSocket not connected';
        statusDiv.style.color = '#e74c3c';
      }
    }
    
    // Debug function to test telemetry handling (call from browser console)
    window.testTelemetry = function() {
      console.log('üß™ Testing telemetry handling...');
      const testData = {
        address: 512,
        motor_dir: false,
        sensor_dir: false,
        max_pwm: 255,
        min_pwm: 30,
        setpoint: 0.0,
        p_gain: 5.0
      };
      handleTelemetry(testData);
    };

    // Function to handle incoming telemetry data
    function handleTelemetry(data) {
      console.log('üéØ handleTelemetry called with:', data);
      const statusDiv = document.getElementById('telemetry-status');
      
      console.log('üì• Processing telemetry:', data);
      
      // List of fields that will be updated
      const updatedFields = [];
      
      // Populate the UI fields with received values
      // Address (always present)
      if (data.address !== undefined) {
        document.getElementById('tune-address').value = data.address;
        updatedFields.push('tune-address');
      }
      
      // Setpoint (wheel actuators only)
      if (data.setpoint !== undefined) {
        document.getElementById('tune-setpoint').value = data.setpoint.toFixed(2);
        updatedFields.push('tune-setpoint');
      }
      
      // Motor direction
      if (data.motor_dir !== undefined) {
        document.getElementById('tune-motor-dir').checked = data.motor_dir;
        document.getElementById('motor-dir-label').textContent = data.motor_dir ? 'Inverted' : 'Normal';
        updatedFields.push('tune-motor-dir');
      }
      
      // Sensor direction (wheel actuators only)
      if (data.sensor_dir !== undefined) {
        document.getElementById('tune-sensor-dir').checked = data.sensor_dir;
        document.getElementById('sensor-dir-label').textContent = data.sensor_dir ? 'Inverted' : 'Normal';
        updatedFields.push('tune-sensor-dir');
      }
      
      // P gain (wheel actuators only)
      if (data.p_gain !== undefined) {
        document.getElementById('tune-p').value = data.p_gain.toFixed(3);
        updatedFields.push('tune-p');
      }
      
      // Max PWM
      if (data.max_pwm !== undefined) {
        document.getElementById('tune-max-pwm').value = data.max_pwm;
        updatedFields.push('tune-max-pwm');
      }
      
      // Min PWM
      if (data.min_pwm !== undefined) {
        document.getElementById('tune-min-pwm').value = data.min_pwm;
        updatedFields.push('tune-min-pwm');
      }
      
      // Update status
      statusDiv.textContent = `‚úÖ Loaded values from actuator 0x${data.address.toString(16).toUpperCase()}`;
      statusDiv.style.color = '#27ae60';
      
      // Flash the input fields to show they've been updated
      updatedFields.forEach(id => {
        const elem = document.getElementById(id);
        if (elem) {
          const originalBg = elem.style.backgroundColor;
          elem.style.backgroundColor = '#d5f4e6';
          elem.style.transition = 'background-color 0.5s';
          setTimeout(() => {
            elem.style.backgroundColor = originalBg;
          }, 1000);
        }
      });
      
      console.log('‚úÖ Telemetry data loaded into UI');
    }
  </script>
</body>
</html>
