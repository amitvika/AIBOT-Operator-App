<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <link rel="stylesheet" href="style.css">

  <style>
    body, html { 
        height: 100vh; 
        margin: 0; 
        padding: 0; 
        overflow: hidden; 
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        display: flex;
        flex-direction: column;
        background-color: #3d3d3d;
    }
    
    #topContainer {
        display: flex;
        flex: 1;
        min-height: 50%;
        gap: 4px;
        padding: 4px 4px 2px 4px;
        box-sizing: border-box;
    }

    #bottomToggle {
        height: 30px;
        background: #555;
        border-top: 1px solid #777;
        border-bottom: 1px solid #333;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        flex-shrink: 0;
        transition: background-color 0.2s ease;
    }
    
    #bottomToggle:hover {
        background: #666;
    }
    
    #bottomToggleButton {
        background: #777;
        color: white;
        border: none;
        padding: 4px 12px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 12px;
        font-weight: bold;
    }
    
    #bottomToggleButton:hover {
        background: #888;
    }

    #robot1UI, #robot2UI {
        flex-basis: 100px;
        flex-shrink: 0;
        padding: 10px;
        background: #f0f0f0;
        border-radius: 4px;
        overflow-y: auto;
    }
    
    .tuning-controls {
        background: #e8e8e8;
        padding: 8px;
        border-radius: 4px;
        margin-top: 5px;
        font-size: 11px;
    }
    
    .tuning-controls label {
        display: block;
        margin: 2px 0;
        font-weight: bold;
    }
    
    .tuning-controls input {
        border: 1px solid #ccc;
        border-radius: 2px;
        padding: 2px 4px;
        font-size: 11px;
    }
    
    .tuning-controls button {
        background: #4CAF50;
        color: white;
        border: none;
        padding: 4px 8px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 11px;
    }
    
    .tuning-controls button:hover {
        background: #45a049;
    }
    #centerPane {
        flex-grow: 1;
        background: #000;
        border-radius: 4px;
        overflow: hidden;
    }
    #centerPane iframe { width: 100%; height: 100%; border: none; }
    
    #bottomContainer {
        display: flex;
        height: 30%;
        gap: 4px;
        padding: 2px 4px 4px 4px;
        box-sizing: border-box;
        transition: height 0.3s ease;
    }
    
    #bottomContainer.hidden {
        height: 0;
        padding: 0;
        overflow: hidden;
    }

    #pane1, #pane3 {
        flex: 1 1 auto;
        position: relative;
        background: #000;
        border-radius: 4px;
        overflow: hidden;
    }
    #pane2 {
        flex: 0 1 auto;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #000;
        border-radius: 4px;
    }

    #aruco_feed { max-width: 100%; max-height: 100%; object-fit: contain; }
    canvas { display: block; width: 100%; height: 100%; }
    .robot-control-panel h4, .robot-control-panel h5 { margin-top: 15px; margin-bottom: 5px; border-bottom: 1px solid #ddd; padding-bottom: 5px; }
    .robot-control-panel h4:first-child { margin-top: 0; }
    .debug-output { font-family: monospace; font-size: 11px; white-space: pre-wrap; word-wrap: break-word; }
  </style>
</head>
<body>
  <div id="topContainer">
    <div id="robot1UI">
        <div class="robot-control-panel">
          <h4>Robot 1</h4>
          <p>Status: <span id="status1">Waiting...</span></p>
          <button id="zeroBtn1">Zero Robot</button>
          <h5>Joint Angles:</h5>
          <div id="jointAngles1" class="debug-output"></div>
          <h5>Joint Limits:</h5>
          <div id="jointLimits1" class="debug-output"></div>
          <h5>Target Pose:</h5>
          <div id="poseDebug1" class="debug-output"></div>
          
          <h5>Tuning Controls:</h5>
          <div class="tuning-controls">
            <label>Left/Right Scale: <input type="number" id="scaleX1" value="-4" step="0.1" style="width: 60px;"></label><br>
            <label>In/Out Scale: <input type="number" id="scaleY1" value="-1" step="0.1" style="width: 60px;"></label><br>
            <label>Up/Down Scale: <input type="number" id="scaleZ1" value="-2" step="0.1" style="width: 60px;"></label><br>
            <label>Left/Right Offset: <input type="number" id="offsetX1" value="-0.3" step="0.1" style="width: 60px;"></label><br>
            <label>In/Out Offset: <input type="number" id="offsetY1" value="1" step="0.1" style="width: 60px;"></label><br>
            <label>Up/Down Offset: <input type="number" id="offsetZ1" value="-0.4" step="0.1" style="width: 60px;"></label><br>
            <button id="applyTuning1" style="margin-top: 5px;">Apply Changes</button>
          </div>
        </div>
    </div>
    <div id="centerPane">
        <iframe src="webrtc.html" frameborder="0"></iframe>
    </div>
    <div id="robot2UI">
        <div class="robot-control-panel">
          <h4>Robot 2</h4>
          <p>Status: <span id="status2">Waiting...</span></p>
          <button id="zeroBtn2">Zero Robot</button>
          <h5>Joint Angles:</h5>
          <div id="jointAngles2" class="debug-output"></div>
          <h5>Joint Limits:</h5>
          <div id="jointLimits2" class="debug-output"></div>
          <h5>Target Pose:</h5>
          <div id="poseDebug2" class="debug-output"></div>
          
          <h5>Tuning Controls:</h5>
          <div class="tuning-controls">
            <label>Left/Right Scale: <input type="number" id="scaleX2" value="-4" step="0.1" style="width: 60px;"></label><br>
            <label>In/Out Scale: <input type="number" id="scaleY2" value="-1" step="0.1" style="width: 60px;"></label><br>
            <label>Up/Down Scale: <input type="number" id="scaleZ2" value="-2" step="0.1" style="width: 60px;"></label><br>
            <label>Left/Right Offset: <input type="number" id="offsetX2" value="0.3" step="0.1" style="width: 60px;"></label><br>
            <label>In/Out Offset: <input type="number" id="offsetY2" value="1" step="0.1" style="width: 60px;"></label><br>
            <label>Up/Down Offset: <input type="number" id="offsetZ2" value="-0.4" step="0.1" style="width: 60px;"></label><br>
            <button id="applyTuning2" style="margin-top: 5px;">Apply Changes</button>
          </div>
        </div>
    </div>
  </div>
  
  <div id="bottomToggle">
    <button id="bottomToggleButton">Hide Bottom Panel</button>
    <button id="fullscreenBtn1" style="margin-left: 10px; background: #777; color: white; border: none; padding: 4px 12px; border-radius: 3px; cursor: pointer; font-size: 12px; font-weight: bold;">Fullscreen View</button>
  </div>
  
  <div id="bottomContainer">
    <div id="pane1"><canvas id="mainThreejsView"></canvas></div>
    <div id="pane2"><img id="aruco_feed"></div>
    <div id="pane3"><canvas id="secondView"></canvas></div>
  </div>
  
  <!-- Fullscreen Three.js View -->
  <div id="fullscreenContainer" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: #000; z-index: 1000;">
    <canvas id="fullscreenThreejsView" style="width: 100%; height: 100%;"></canvas>
    <div id="fullscreenArUcoPanel" style="position: absolute; top: 20px; right: 20px; width: 200px; height: 150px; background: rgba(0,0,0,0.8); border-radius: 8px; overflow: hidden; border: 2px solid #fff;">
      <img id="fullscreenArUcoFeed" style="width: 100%; height: 100%; object-fit: contain;">
    </div>
    <button id="exitFullscreenBtn" style="position: absolute; top: 20px; left: 20px; background: #f44336; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold;">Exit Fullscreen</button>
  </div>
  
  <script>
    const ui = {
        1: { 
            joints: document.getElementById("jointAngles1"), 
            status: document.getElementById("status1"), 
            pose: document.getElementById("poseDebug1"),
            limits: document.getElementById("jointLimits1")
        },
        2: { 
            joints: document.getElementById("jointAngles2"), 
            status: document.getElementById("status2"), 
            pose: document.getElementById("poseDebug2"),
            limits: document.getElementById("jointLimits2")
        }
    };
    
    let scene, r1_view, r2_view, fullscreen_view;
    let robotGroup1, robotGroup2;
    let robot1Joints = [0,0,0,0,0,0], robot2Joints = [0,0,0,0,0,0];
    let isFullscreen = false;
    
    // Bottom panel toggle state
    let bottomPanelHidden = false;

    // *** OPTIMIZATION: State variables to hold the latest data from Python ***
    // This allows us to decouple data arrival from rendering updates.
    let robot1UpdateData = null;
    let robot2UpdateData = null;

    const R1_MAT = new THREE.MeshLambertMaterial({color: 0x6688ff});
    const R2_MAT = new THREE.MeshLambertMaterial({color: 0xff6666});
    const R1_LIMIT_MAT = new THREE.MeshLambertMaterial({color: 0xffaa00}); // Orange for limit violations
    const R2_LIMIT_MAT = new THREE.MeshLambertMaterial({color: 0xff4400}); // Red-orange for limit violations
    const LINK_MAT = new THREE.LineBasicMaterial({ 
        color: 0xffffff, 
        linewidth: 2,
        transparent: false,
        opacity: 1.0
    });

    function createRobotGroup(jointMaterial) {
        const group = new THREE.Group();
        // Create 7 joint spheres (base + 6 joints)
        for (let i = 0; i < 7; i++) { 
            group.add(new THREE.Mesh(new THREE.SphereGeometry(.01), jointMaterial)); 
        }
        // Create end effector as 3-axis helper (replaces the 8th sphere)
        const endEffector = new THREE.AxesHelper(0.06); // 6cm axes helper (3x bigger)
        group.add(endEffector);
        
        // Create line geometry for connecting all points (base + 6 joints + 1 end effector = 8 points)
        const lineGeometry = new THREE.BufferGeometry();
        lineGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(8 * 3), 3));
        group.add(new THREE.Line(lineGeometry, LINK_MAT));
        return group;
    }
    
    function setupView(canvasId, isPerspective) {
        const pane = document.getElementById(canvasId).parentElement;
        const renderer = new THREE.WebGLRenderer({antialias: true, canvas: document.getElementById(canvasId)});
        renderer.setSize(pane.clientWidth, pane.clientHeight);
        
        const aspect = pane.clientWidth / pane.clientHeight;
        let camera;
        if (isPerspective) {
            // Left side - perspective view (zoomed out 6x from original)
            camera = new THREE.PerspectiveCamera(65, aspect, 0.0001, 20.0);
            camera.position.set(0, -0.6, 0.48); // Zoomed out 6x from original position
        } else {
            // Right side - side view looking at green and blue axis plane
            camera = new THREE.PerspectiveCamera(65, aspect, 0.0001, 20.0);
            camera.position.set(-0.8, 0, 0.2); // Positioned further back and lower for better side view
            camera.up.set(0, 0, 1); // Set blue axis (Z) as up direction
        }
        camera.lookAt(0,0,0);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        return { renderer, camera, controls };
    }

    function init(){
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        const grid = new THREE.GridHelper(1.0, 20, 0x444444, 0x444444);
        grid.rotation.x = Math.PI / 2; // Rotate 90 degrees to align with XY plane (red and green axes)
        scene.add(grid);
        scene.add(new THREE.AxesHelper(0.5)); // Larger axes helper to match grid
        scene.add(new THREE.AmbientLight(0x404040));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(0.05, -0.2, 0.1); // Scaled from meters to mm (1000x smaller)
        scene.add(dirLight);

        robotGroup1 = createRobotGroup(R1_MAT); scene.add(robotGroup1);
        robotGroup2 = createRobotGroup(R2_MAT); scene.add(robotGroup2);

        r1_view = setupView('mainThreejsView', true);
        r2_view = setupView('secondView', false);
        fullscreen_view = setupView('fullscreenThreejsView', true);
        
        onWindowResize();
        animate();
        
        if (window.pywebview) {
            // *** OPTIMIZATION: The response from Python will now be handled in the animation loop ***
            window.pywebview.api.go_to_zero_robot1().then(res => handle_robot_update(1, res));
            window.pywebview.api.go_to_zero_robot2().then(res => handle_robot_update(2, res));
        }
        
        // Initialize bottom panel toggle
        initializeBottomPanelToggle();
    }

    function updateRobot(grp, positions, jointAngles = null, violations = [], limits = {}, velocity_violations = []){
        if (!positions || positions.length < 1) return;
        const line = grp.children.find(c => c.type === 'Line');
        if(!line) return;
        const points = line.geometry.attributes.position.array;
        
        // Determine if this is robot 1 or 2 based on the group
        const isRobot1 = grp === robotGroup1;
        const limitMat = isRobot1 ? R1_LIMIT_MAT : R2_LIMIT_MAT;
        const normalMat = isRobot1 ? R1_MAT : R2_MAT;
        
        // Create velocity violation material (orange/yellow)
        const velocityMat = new THREE.MeshBasicMaterial({ 
            color: isRobot1 ? 0xff8800 : 0xffaa00, // Orange for robot 1, lighter orange for robot 2
            transparent: false,
            opacity: 1.0
        });
        
        // Update joint positions (first 7 positions: base + 6 joints)
        for (let i = 0; i < Math.min(positions.length, 7); i++) {
            const pos = positions[i];
                grp.children[i].position.set(pos[0], pos[1], pos[2]);
            points[i * 3] = pos[0];
            points[i * 3 + 1] = pos[1];
            points[i * 3 + 2] = pos[2];
            
            // Change joint color based on violations (prioritize limit violations over velocity violations)
            if ((violations.length > 0 || velocity_violations.length > 0) && jointAngles && i > 0) { // Skip base joint (index 0)
                const violation = violations.find(v => v.joint_index === (i - 1)); // Joint angles start from index 0, but positions include base
                const velocity_violation = velocity_violations.find(v => v.joint_index === (i - 1));
                
                if (violation) {
                    grp.children[i].material = limitMat; // Red for limit violations (highest priority)
                } else if (velocity_violation) {
                    grp.children[i].material = velocityMat; // Orange for velocity violations
                } else {
                    grp.children[i].material = normalMat;
                }
            } else {
                grp.children[i].material = normalMat;
            }
        }
        
        // Update end effector position and orientation (positions 7 and 8)
        if (positions.length >= 8) {
            const endEffectorPos = positions[7]; // End effector position
            const endEffectorOri = positions[8]; // End effector orientation quaternion
            const endEffector = grp.children[7]; // End effector is the 8th child (index 7)
            
            // Set position
            endEffector.position.set(endEffectorPos[0], endEffectorPos[1], endEffectorPos[2]);
            
            // Set orientation if quaternion is provided
            if (endEffectorOri && endEffectorOri.length >= 4) {
                endEffector.quaternion.set(endEffectorOri[0], endEffectorOri[1], endEffectorOri[2], endEffectorOri[3]);
            }
            
            // Add end effector position to line (8th point)
            points[7 * 3] = endEffectorPos[0];
            points[7 * 3 + 1] = endEffectorPos[1];
            points[7 * 3 + 2] = endEffectorPos[2];
        }
        
        // Always draw 8 points (base + 6 joints + 1 end effector)
        line.geometry.setDrawRange(0, 8);
        line.geometry.attributes.position.needsUpdate = true;
    }

    // *** OPTIMIZATION: Switched to requestAnimationFrame for all rendering and DOM updates ***
    // This ensures updates are synchronized with the browser's repaint cycle, leading to much smoother visuals.
    function animate(){
        requestAnimationFrame(animate);

        // Check if there is pending update data for Robot 1 and apply it
        if (robot1UpdateData) {
            apply_robot_update(1, robot1UpdateData);
            robot1UpdateData = null; // Consume the data to prevent re-rendering
        }
        // Check if there is pending update data for Robot 2 and apply it
        if (robot2UpdateData) {
            apply_robot_update(2, robot2UpdateData);
            robot2UpdateData = null; // Consume the data
        }

        r1_view.controls.update();
        r1_view.renderer.render(scene, r1_view.camera);
        r2_view.controls.update();
        r2_view.renderer.render(scene, r2_view.camera);
        
        // Render fullscreen view if active
        if (isFullscreen && fullscreen_view) {
            fullscreen_view.controls.update();
            fullscreen_view.renderer.render(scene, fullscreen_view.camera);
        }
    }

    // *** OPTIMIZATION: This function is called from Python and just stores the latest data ***
    function handle_robot_update(robotId, data) {
        // OPTIMIZATION: Faster duplicate detection using simple hash instead of JSON.stringify
        const dataHash = data.positions ? data.positions.join(',') + (data.joint_angles ? data.joint_angles.join(',') : '') : '';
        
        if (robotId === 1) {
            if (robot1UpdateData && robot1UpdateData.hash === dataHash) {
                return; // Skip identical updates
            }
            data.hash = dataHash; // Add hash for next comparison
            robot1UpdateData = data;
        } else {
            if (robot2UpdateData && robot2UpdateData.hash === dataHash) {
                return; // Skip identical updates
            }
            data.hash = dataHash; // Add hash for next comparison
            robot2UpdateData = data;
        }
    }

    // *** OPTIMIZATION: This new function contains the original update logic ***
    // It's now called from within the animation loop to ensure smooth rendering.
    function apply_robot_update(robotId, data) {
        const positions_key = `positions${robotId}` in data ? `positions${robotId}` : 'positions';
        const angles_key = `joint_angles${robotId}` in data ? `joint_angles${robotId}` : 'joint_angles';
        const violations_key = `joint_limit_violations${robotId}` in data ? `joint_limit_violations${robotId}` : 'joint_limit_violations';
        const velocity_violations_key = `velocity_limit_violations${robotId}` in data ? `velocity_limit_violations${robotId}` : 'velocity_limit_violations';
        const limits_key = `joint_limits${robotId}` in data ? `joint_limits${robotId}` : 'joint_limits';
        const velocity_limits_key = `velocity_limits${robotId}` in data ? `velocity_limits${robotId}` : 'velocity_limits';

        if (data && data[positions_key]) {
            const robotGroup = (robotId === 1) ? robotGroup1 : robotGroup2;
            const jointAngles = data[angles_key];
            const violations = data[violations_key] || [];
            const velocity_violations = data[velocity_violations_key] || [];
            const limits = data[limits_key] || {};
            const velocity_limits = data[velocity_limits_key] || [];
            
            updateRobot(robotGroup, data[positions_key], jointAngles, violations, limits, velocity_violations);
            
            if (ui[robotId] && jointAngles) {
                if (robotId === 1) robot1Joints = jointAngles;
                else robot2Joints = jointAngles;
                
                // Display joint angles with limit and velocity violation indicators
                let jointDisplay = jointAngles.map((a, i) => {
                    const violation = violations.find(v => v.joint_index === i);
                    const velocity_violation = velocity_violations.find(v => v.joint_index === i);
                    
                    let indicators = [];
                    if (violation) indicators.push('<span style="color: red;">⚠️ LIMIT</span>');
                    if (velocity_violation) indicators.push('<span style="color: orange;">⚡ VEL</span>');
                    
                    return `J${i+1}=${a} ${indicators.join(' ')}`;
                }).join("<br>");
                
                ui[robotId].joints.innerHTML = jointDisplay;
                
                // Update status based on both types of violations
                const hasViolations = violations.length > 0 || velocity_violations.length > 0;
                let statusText = 'Active';
                if (violations.length > 0 && velocity_violations.length > 0) {
                    statusText = 'Limit & Velocity Violation';
                } else if (violations.length > 0) {
                    statusText = 'Limit Violation';
                } else if (velocity_violations.length > 0) {
                    statusText = 'Velocity Violation';
                }
                
                ui[robotId].status.textContent = statusText;
                ui[robotId].status.style.color = hasViolations ? "red" : "green";
                
                // Display joint limits information
                if (limits.lower && limits.upper && limits.names) {
                    let limitsDisplay = limits.names.map((name, i) => {
                        const lower = (limits.lower[i] * 180 / Math.PI).toFixed(1);
                        const upper = (limits.upper[i] * 180 / Math.PI).toFixed(1);
                        const violation = violations.find(v => v.joint_index === i);
                        const velocity_violation = velocity_violations.find(v => v.joint_index === i);
                        const velocity_limit = velocity_limits[i] ? (velocity_limits[i] * 180 / Math.PI).toFixed(1) : 'N/A';
                        
                        let style = '';
                        if (violation) style = 'color: red; font-weight: bold;';
                        else if (velocity_violation) style = 'color: orange; font-weight: bold;';
                        
                        return `<span style="${style}">${name}: [${lower}°, ${upper}°] (vel: ${velocity_limit}°/s)</span>`;
                    }).join("<br>");
                    ui[robotId].limits.innerHTML = limitsDisplay;
                }

                updateAndSendControlString();
            }

            if (ui[robotId] && data.debug_pose) {
                const pose = data.debug_pose;
                ui[robotId].pose.innerHTML = 
                    `X: ${pose.x.toFixed(2)}<br>` +
                    `Y: ${pose.y.toFixed(2)}<br>` +
                    `Z: ${pose.z.toFixed(2)}<br>` +
                    `Roll: ${pose.roll.toFixed(2)}<br>` +
                    `Pitch: ${pose.pitch.toFixed(2)}<br>` +
                    `Yaw: ${pose.yaw.toFixed(2)}`;
            }
        }
    }
    
    function updateAndSendControlString() {
        let str = "mac=asda;";
        const jn = ["X","Y","Z","p","y","r"];
        for (let i=0; i<6; i++) { str += `h1${jn[i]}=${robot1Joints[i] || 0};`; }
        for (let i=0; i<6; i++) { str += `h2${jn[i]}=${robot2Joints[i] || 0};`; }

        if (window.pywebview) {
            window.pywebview.api.get_latest_serial().then(res => {
                str += (res.serial || "") + ";";
                const iframe = document.querySelector("#centerPane iframe");
                if (iframe) iframe.contentWindow.postMessage({ controlString: str }, "*");
            });
        }
    }

    // Continuous controller data transmission - independent of ArUco detection
    function sendControllerDataContinuously() {
        if (window.pywebview) {
            window.pywebview.api.get_latest_serial().then(res => {
                const serialData = res.serial || "";
                const iframe = document.querySelector("#centerPane iframe");
                if (iframe && serialData) {
                    // Send just the controller data without robot joint data
                    const controlString = "mac=asda;" + serialData + ";";
                    iframe.contentWindow.postMessage({ controlString: controlString }, "*");
                }
            });
        }
        // Send controller data every 100ms regardless of ArUco detection
        setTimeout(sendControllerDataContinuously, 100);
    }

    // --- Bottom Panel Toggle Functions ---
    function initializeBottomPanelToggle() {
        const toggleButton = document.getElementById('bottomToggleButton');
        const bottomContainer = document.getElementById('bottomContainer');
        
        toggleButton.addEventListener('click', () => {
            bottomPanelHidden = !bottomPanelHidden;
            bottomContainer.classList.toggle('hidden', bottomPanelHidden);
            
            if (bottomPanelHidden) {
                toggleButton.textContent = 'Show Bottom Panel';
            } else {
                toggleButton.textContent = 'Hide Bottom Panel';
                // Update Three.js renderers when showing - use multiple timeouts to ensure proper sizing
                setTimeout(onWindowResize, 50);
                setTimeout(onWindowResize, 200);
                setTimeout(onWindowResize, 500);
            }
        });
    }

    document.getElementById("zeroBtn1").addEventListener("click", () => {
        if(window.pywebview) window.pywebview.api.go_to_zero_robot1().then(res => handle_robot_update(1, res));
    });
    document.getElementById("zeroBtn2").addEventListener("click", () => {
        if(window.pywebview) window.pywebview.api.go_to_zero_robot2().then(res => handle_robot_update(2, res));
    });
    
    // Fullscreen functionality
    document.getElementById("fullscreenBtn1").addEventListener("click", () => {
        enterFullscreen();
    });
    document.getElementById("exitFullscreenBtn").addEventListener("click", () => {
        exitFullscreen();
    });

    function onWindowResize(){
        const bottomContainer = document.getElementById('bottomContainer');
        
        // Handle fullscreen resize
        if (isFullscreen && fullscreen_view) {
            fullscreen_view.renderer.setSize(window.innerWidth, window.innerHeight);
            fullscreen_view.camera.aspect = window.innerWidth / window.innerHeight;
            fullscreen_view.camera.updateProjectionMatrix();
        }
        
        // Only update Three.js renderers if bottom panel is not hidden
        if (!bottomContainer.classList.contains('hidden')) {
            // Force a layout recalculation
            bottomContainer.offsetHeight;
            
            // Left side - perspective view
        let pane3 = document.getElementById("mainThreejsView").parentElement;
            if (pane3 && r1_view && r1_view.renderer) {
        r1_view.renderer.setSize(pane3.clientWidth, pane3.clientHeight);
        r1_view.camera.aspect = pane3.clientWidth / pane3.clientHeight;
        r1_view.camera.updateProjectionMatrix();
            }
        
            // Right side - perspective view
        let pane1 = document.getElementById("secondView").parentElement;
            if (pane1 && r2_view && r2_view.renderer) {
        r2_view.renderer.setSize(pane1.clientWidth, pane1.clientHeight);
                r2_view.camera.aspect = pane1.clientWidth / pane1.clientHeight;
        r2_view.camera.updateProjectionMatrix();
    }
        }
    }
    
    // Function to fetch and populate tuning parameters from backend
    function fetchAndPopulateTuningParams() {
        if (window.pywebview && window.pywebview.api.get_tuning_params) {
            window.pywebview.api.get_tuning_params().then(params => {
                console.log('Fetched tuning parameters:', params);
                
                // Update Robot 1 input boxes
                document.getElementById('scaleX1').value = params.scale[0];
                document.getElementById('scaleY1').value = params.scale[1];
                document.getElementById('scaleZ1').value = params.scale[2];
                document.getElementById('offsetX1').value = params.offset_robot1[0];
                document.getElementById('offsetY1').value = params.offset_robot1[1];
                document.getElementById('offsetZ1').value = params.offset_robot1[2];
                
                // Update Robot 2 input boxes
                document.getElementById('scaleX2').value = params.scale[0];
                document.getElementById('scaleY2').value = params.scale[1];
                document.getElementById('scaleZ2').value = params.scale[2];
                document.getElementById('offsetX2').value = params.offset_robot2[0];
                document.getElementById('offsetY2').value = params.offset_robot2[1];
                document.getElementById('offsetZ2').value = params.offset_robot2[2];
                
                console.log('Updated input boxes with current backend values');
            }).catch(error => {
                console.error('Error fetching tuning parameters:', error);
            });
        }
    }
    
    // Tuning controls functionality
    function setupTuningControls() {
        // Robot 1 tuning
        document.getElementById('applyTuning1').addEventListener('click', function() {
            const scaleX = parseFloat(document.getElementById('scaleX1').value);
            const scaleY = parseFloat(document.getElementById('scaleY1').value);
            const scaleZ = parseFloat(document.getElementById('scaleZ1').value);
            const offsetX = parseFloat(document.getElementById('offsetX1').value);
            const offsetY = parseFloat(document.getElementById('offsetY1').value);
            const offsetZ = parseFloat(document.getElementById('offsetZ1').value);
            
            // Send tuning parameters to Python backend
            if (window.pywebview) {
                window.pywebview.api.update_tuning_params(1, {
                    scale: [scaleX, scaleY, scaleZ],
                    offset: [offsetX, offsetY, offsetZ]
                });
            }
            console.log('Applied Robot 1 tuning:', {scale: [scaleX, scaleY, scaleZ], offset: [offsetX, offsetY, offsetZ]});
        });
        
        // Robot 2 tuning
        document.getElementById('applyTuning2').addEventListener('click', function() {
            const scaleX = parseFloat(document.getElementById('scaleX2').value);
            const scaleY = parseFloat(document.getElementById('scaleY2').value);
            const scaleZ = parseFloat(document.getElementById('scaleZ2').value);
            const offsetX = parseFloat(document.getElementById('offsetX2').value);
            const offsetY = parseFloat(document.getElementById('offsetY2').value);
            const offsetZ = parseFloat(document.getElementById('offsetZ2').value);
            
            // Send tuning parameters to Python backend
            if (window.pywebview) {
                window.pywebview.api.update_tuning_params(2, {
                    scale: [scaleX, scaleY, scaleZ],
                    offset: [offsetX, offsetY, offsetZ]
                });
            }
            console.log('Applied Robot 2 tuning:', {scale: [scaleX, scaleY, scaleZ], offset: [offsetX, offsetY, offsetZ]});
        });
    }
    
    // Fullscreen functions
    function enterFullscreen() {
        isFullscreen = true;
        document.getElementById('fullscreenContainer').style.display = 'block';
        
        // Resize fullscreen renderer to full window size
        if (fullscreen_view) {
            fullscreen_view.renderer.setSize(window.innerWidth, window.innerHeight);
            fullscreen_view.camera.aspect = window.innerWidth / window.innerHeight;
            fullscreen_view.camera.updateProjectionMatrix();
            
            // Copy camera settings from main view to fullscreen view
            if (r1_view) {
                fullscreen_view.camera.position.copy(r1_view.camera.position);
                fullscreen_view.camera.quaternion.copy(r1_view.camera.quaternion);
                fullscreen_view.controls.update();
            }
        }
        
        // Start copying ArUco feed to fullscreen panel
        startFullscreenArUcoFeed();
    }
    
    function exitFullscreen() {
        isFullscreen = false;
        document.getElementById('fullscreenContainer').style.display = 'none';
        stopFullscreenArUcoFeed();
    }
    
    function startFullscreenArUcoFeed() {
        const fullscreenArUcoFeed = document.getElementById('fullscreenArUcoFeed');
        const arucoFeed = document.getElementById('aruco_feed');
        
        // Copy the ArUco feed to fullscreen panel
        function updateFullscreenArUco() {
            if (isFullscreen && arucoFeed.src) {
                fullscreenArUcoFeed.src = arucoFeed.src;
            }
            if (isFullscreen) {
                requestAnimationFrame(updateFullscreenArUco);
            }
        }
        updateFullscreenArUco();
    }
    
    function stopFullscreenArUcoFeed() {
        // Stop the ArUco feed copying
    }
    
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('pywebviewready', function() {
        init();
        setupTuningControls();
        // Fetch and populate tuning parameters after setup
        fetchAndPopulateTuningParams();
        // Start continuous controller data transmission
        sendControllerDataContinuously();
    });
  </script>
</body>
</html>