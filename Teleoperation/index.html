<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <link rel="stylesheet" href="style.css">

  <style>
    body, html { 
        height: 100vh; 
        margin: 0; 
        padding: 0; 
        overflow: hidden; 
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        display: flex;
        flex-direction: column;
        background-color: #3d3d3d;
    }
    
    #topContainer {
        display: flex;
        flex: 1;
        min-height: 50%;
        gap: 4px;
        padding: 4px 4px 2px 4px;
        box-sizing: border-box;
    }
    
    #bottomToggle {
        height: 30px;
        background: #555;
        border-top: 1px solid #777;
        border-bottom: 1px solid #333;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        flex-shrink: 0;
        transition: background-color 0.2s ease;
    }
    
    #bottomToggle:hover {
        background: #666;
    }
    
    #bottomToggleButton {
        background: #777;
        color: white;
        border: none;
        padding: 4px 12px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 12px;
        font-weight: bold;
    }
    
    #bottomToggleButton:hover {
        background: #888;
    }

    #robot1UI, #robot2UI {
        flex-basis: 100px;
        flex-shrink: 0;
        padding: 10px;
        background: #f0f0f0;
        border-radius: 4px;
        overflow-y: auto;
    }
    #centerPane {
        flex-grow: 1;
        background: #000;
        border-radius: 4px;
        overflow: hidden;
    }
    #centerPane iframe { width: 100%; height: 100%; border: none; }
    
    #bottomContainer {
        display: flex;
        height: 30%;
        gap: 4px;
        padding: 2px 4px 4px 4px;
        box-sizing: border-box;
        transition: height 0.3s ease;
    }
    
    #bottomContainer.hidden {
        height: 0;
        padding: 0;
        overflow: hidden;
    }

    #pane1, #pane3 {
        flex: 1 1 auto;
        position: relative;
        background: #000;
        border-radius: 4px;
        overflow: hidden;
    }
    #pane2 {
        flex: 0 1 auto;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #000;
        border-radius: 4px;
    }

    #aruco_feed { max-width: 100%; max-height: 100%; object-fit: contain; }
    canvas { display: block; width: 100%; height: 100%; }
    .robot-control-panel h4, .robot-control-panel h5 { margin-top: 15px; margin-bottom: 5px; border-bottom: 1px solid #ddd; padding-bottom: 5px; }
    .robot-control-panel h4:first-child { margin-top: 0; }
    .debug-output { font-family: monospace; font-size: 11px; white-space: pre-wrap; word-wrap: break-word; }
  </style>
</head>
<body>
  <div id="topContainer">
    <div id="robot1UI">
        <div class="robot-control-panel">
          <h4>Robot 1</h4>
          <p>Status: <span id="status1">Waiting...</span></p>
          <button id="zeroBtn1">Zero Robot</button>
          <h5>Joint Angles:</h5>
          <div id="jointAngles1" class="debug-output"></div>
          <h5>Joint Limits:</h5>
          <div id="jointLimits1" class="debug-output"></div>
          <h5>Target Pose:</h5>
          <div id="poseDebug1" class="debug-output"></div>
        </div>
    </div>
    <div id="centerPane">
        <iframe src="webrtc.html" frameborder="0"></iframe>
    </div>
    <div id="robot2UI">
        <div class="robot-control-panel">
          <h4>Robot 2</h4>
          <p>Status: <span id="status2">Waiting...</span></p>
          <button id="zeroBtn2">Zero Robot</button>
          <h5>Joint Angles:</h5>
          <div id="jointAngles2" class="debug-output"></div>
          <h5>Joint Limits:</h5>
          <div id="jointLimits2" class="debug-output"></div>
          <h5>Target Pose:</h5>
          <div id="poseDebug2" class="debug-output"></div>
        </div>
    </div>
  </div>
  
  <div id="bottomToggle">
    <button id="bottomToggleButton">Hide Bottom Panel</button>
  </div>
  
  <div id="bottomContainer">
    <div id="pane1"><canvas id="mainThreejsView"></canvas></div>
    <div id="pane2"><img id="aruco_feed"></div>
    <div id="pane3"><canvas id="secondView"></canvas></div>
  </div>
  
  <script>
    const ui = {
        1: { 
            joints: document.getElementById("jointAngles1"), 
            status: document.getElementById("status1"), 
            pose: document.getElementById("poseDebug1"),
            limits: document.getElementById("jointLimits1")
        },
        2: { 
            joints: document.getElementById("jointAngles2"), 
            status: document.getElementById("status2"), 
            pose: document.getElementById("poseDebug2"),
            limits: document.getElementById("jointLimits2")
        }
    };
    
    let scene, r1_view, r2_view;
    let robotGroup1, robotGroup2;
    let robot1Joints = [0,0,0,0,0,0], robot2Joints = [0,0,0,0,0,0];
    
    // Bottom panel toggle state
    let bottomPanelHidden = false;

    // *** OPTIMIZATION: State variables to hold the latest data from Python ***
    // This allows us to decouple data arrival from rendering updates.
    let robot1UpdateData = null;
    let robot2UpdateData = null;

    const R1_MAT = new THREE.MeshLambertMaterial({color: 0x6688ff});
    const R2_MAT = new THREE.MeshLambertMaterial({color: 0xff6666});
    const R1_LIMIT_MAT = new THREE.MeshLambertMaterial({color: 0xffaa00}); // Orange for limit violations
    const R2_LIMIT_MAT = new THREE.MeshLambertMaterial({color: 0xff4400}); // Red-orange for limit violations
    const LINK_MAT = new THREE.LineBasicMaterial({ 
        color: 0xffffff, 
        linewidth: 2,
        transparent: false,
        opacity: 1.0
    });

    function createRobotGroup(jointMaterial) {
        const group = new THREE.Group();
        // Create 7 joint spheres (base + 6 joints)
        for (let i = 0; i < 7; i++) { 
            group.add(new THREE.Mesh(new THREE.SphereGeometry(.01), jointMaterial)); 
        }
        // Create end effector as 3-axis helper (replaces the 8th sphere)
        const endEffector = new THREE.AxesHelper(0.02); // 2cm axes helper
        group.add(endEffector);
        
        // Create line geometry for connecting all points (base + 6 joints + 1 end effector = 8 points)
        const lineGeometry = new THREE.BufferGeometry();
        lineGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(8 * 3), 3));
        group.add(new THREE.Line(lineGeometry, LINK_MAT));
        return group;
    }
    
    function setupView(canvasId, isPerspective) {
        const pane = document.getElementById(canvasId).parentElement;
        const renderer = new THREE.WebGLRenderer({antialias: true, canvas: document.getElementById(canvasId)});
        renderer.setSize(pane.clientWidth, pane.clientHeight);
        
        const aspect = pane.clientWidth / pane.clientHeight;
        let camera;
        if (isPerspective) {
            camera = new THREE.PerspectiveCamera(65, aspect, 0.0001, 20.0); // Increased far plane for zoom out
            camera.position.set(0, -0.1, 0.08); // Scaled for mm URDF (robot is now 1000x smaller)
        } else {
            camera = new THREE.OrthographicCamera(-0.05 * aspect, 0.05 * aspect, 0.07, -0.03, -0.1, 0.5);
            camera.position.set(0, 0, 0.1); // Scaled for mm URDF (robot is now 1000x smaller)
        }
        camera.lookAt(0,0,0);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        return { renderer, camera, controls };
    }

    function init(){
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        const grid = new THREE.GridHelper(1.0, 20, 0x444444, 0x444444);
        grid.rotation.x = Math.PI / 2; // Rotate 90 degrees to align with XY plane (red and green axes)
        scene.add(grid);
        scene.add(new THREE.AxesHelper(0.5)); // Larger axes helper to match grid
        scene.add(new THREE.AmbientLight(0x404040));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(0.05, -0.2, 0.1); // Scaled from meters to mm (1000x smaller)
        scene.add(dirLight);

        robotGroup1 = createRobotGroup(R1_MAT); scene.add(robotGroup1);
        robotGroup2 = createRobotGroup(R2_MAT); scene.add(robotGroup2);

        r1_view = setupView('mainThreejsView', true);
        r2_view = setupView('secondView', false);
        
        onWindowResize();
        animate();
        
        if (window.pywebview) {
            // *** OPTIMIZATION: The response from Python will now be handled in the animation loop ***
            window.pywebview.api.go_to_zero_robot1().then(res => handle_robot_update(1, res));
            window.pywebview.api.go_to_zero_robot2().then(res => handle_robot_update(2, res));
        }
        
        // Initialize bottom panel toggle
        initializeBottomPanelToggle();
    }

    function updateRobot(grp, positions, jointAngles = null, violations = [], limits = {}){
        if (!positions || positions.length < 1) return;
        const line = grp.children.find(c => c.type === 'Line');
        if(!line) return;
        const points = line.geometry.attributes.position.array;
        
        // Determine if this is robot 1 or 2 based on the group
        const isRobot1 = grp === robotGroup1;
        const limitMat = isRobot1 ? R1_LIMIT_MAT : R2_LIMIT_MAT;
        const normalMat = isRobot1 ? R1_MAT : R2_MAT;
        
        // Update joint positions (first 7 positions: base + 6 joints)
        for (let i = 0; i < Math.min(positions.length, 7); i++) {
            const pos = positions[i];
            grp.children[i].position.set(pos[0], pos[1], pos[2]);
            points[i * 3] = pos[0];
            points[i * 3 + 1] = pos[1];
            points[i * 3 + 2] = pos[2];
            
            // Change joint color if it's at a limit
            if (violations.length > 0 && jointAngles && i > 0) { // Skip base joint (index 0)
                const violation = violations.find(v => v.joint_index === (i - 1)); // Joint angles start from index 0, but positions include base
                if (violation) {
                    grp.children[i].material = limitMat;
                } else {
                    grp.children[i].material = normalMat;
                }
            } else {
                grp.children[i].material = normalMat;
            }
        }
        
        // Update end effector position and orientation (positions 7 and 8)
        if (positions.length >= 8) {
            const endEffectorPos = positions[7]; // End effector position
            const endEffectorOri = positions[8]; // End effector orientation quaternion
            const endEffector = grp.children[7]; // End effector is the 8th child (index 7)
            
            // Set position
            endEffector.position.set(endEffectorPos[0], endEffectorPos[1], endEffectorPos[2]);
            
            // Set orientation if quaternion is provided
            if (endEffectorOri && endEffectorOri.length >= 4) {
                endEffector.quaternion.set(endEffectorOri[0], endEffectorOri[1], endEffectorOri[2], endEffectorOri[3]);
            }
            
            // Add end effector position to line (8th point)
            points[7 * 3] = endEffectorPos[0];
            points[7 * 3 + 1] = endEffectorPos[1];
            points[7 * 3 + 2] = endEffectorPos[2];
        }
        
        // Always draw 8 points (base + 6 joints + 1 end effector)
        line.geometry.setDrawRange(0, 8);
        line.geometry.attributes.position.needsUpdate = true;
    }

    // *** OPTIMIZATION: Switched to requestAnimationFrame for all rendering and DOM updates ***
    // This ensures updates are synchronized with the browser's repaint cycle, leading to much smoother visuals.
    function animate(){
        requestAnimationFrame(animate);

        // Check if there is pending update data for Robot 1 and apply it
        if (robot1UpdateData) {
            apply_robot_update(1, robot1UpdateData);
            robot1UpdateData = null; // Consume the data to prevent re-rendering
        }
        // Check if there is pending update data for Robot 2 and apply it
        if (robot2UpdateData) {
            apply_robot_update(2, robot2UpdateData);
            robot2UpdateData = null; // Consume the data
        }

        r1_view.controls.update();
        r1_view.renderer.render(scene, r1_view.camera);
        r2_view.controls.update();
        r2_view.renderer.render(scene, r2_view.camera);
    }

    // *** OPTIMIZATION: This function is called from Python and just stores the latest data ***
    function handle_robot_update(robotId, data) {
        if (robotId === 1) {
            robot1UpdateData = data;
        } else {
            robot2UpdateData = data;
        }
    }

    // *** OPTIMIZATION: This new function contains the original update logic ***
    // It's now called from within the animation loop to ensure smooth rendering.
    function apply_robot_update(robotId, data) {
        const positions_key = `positions${robotId}` in data ? `positions${robotId}` : 'positions';
        const angles_key = `joint_angles${robotId}` in data ? `joint_angles${robotId}` : 'joint_angles';
        const violations_key = `joint_limit_violations${robotId}` in data ? `joint_limit_violations${robotId}` : 'joint_limit_violations';
        const limits_key = `joint_limits${robotId}` in data ? `joint_limits${robotId}` : 'joint_limits';

        if (data && data[positions_key]) {
            const robotGroup = (robotId === 1) ? robotGroup1 : robotGroup2;
            const jointAngles = data[angles_key];
            const violations = data[violations_key] || [];
            const limits = data[limits_key] || {};
            
            updateRobot(robotGroup, data[positions_key], jointAngles, violations, limits);
            
            if (ui[robotId] && jointAngles) {
                if (robotId === 1) robot1Joints = jointAngles;
                else robot2Joints = jointAngles;
                
                // Display joint angles with limit violation indicators
                let jointDisplay = jointAngles.map((a, i) => {
                    const violation = violations.find(v => v.joint_index === i);
                    if (violation) {
                        return `J${i+1}=${a} <span style="color: red;">⚠️ LIMIT</span>`;
                    }
                    return `J${i+1}=${a}`;
                }).join("<br>");
                
                ui[robotId].joints.innerHTML = jointDisplay;
                ui[robotId].status.textContent = violations.length > 0 ? 'Limit Violation' : 'Active';
                ui[robotId].status.style.color = violations.length > 0 ? "red" : "green";
                
                // Display joint limits information
                if (limits.lower && limits.upper && limits.names) {
                    let limitsDisplay = limits.names.map((name, i) => {
                        const lower = (limits.lower[i] * 180 / Math.PI).toFixed(1);
                        const upper = (limits.upper[i] * 180 / Math.PI).toFixed(1);
                        const violation = violations.find(v => v.joint_index === i);
                        const style = violation ? 'color: red; font-weight: bold;' : '';
                        return `<span style="${style}">${name}: [${lower}°, ${upper}°]</span>`;
                    }).join("<br>");
                    ui[robotId].limits.innerHTML = limitsDisplay;
                }

                updateAndSendControlString();
            }

            if (ui[robotId] && data.debug_pose) {
                const pose = data.debug_pose;
                ui[robotId].pose.innerHTML = 
                    `X: ${pose.x.toFixed(2)}<br>` +
                    `Y: ${pose.y.toFixed(2)}<br>` +
                    `Z: ${pose.z.toFixed(2)}<br>` +
                    `Roll: ${pose.roll.toFixed(2)}<br>` +
                    `Pitch: ${pose.pitch.toFixed(2)}<br>` +
                    `Yaw: ${pose.yaw.toFixed(2)}`;
            }
        }
    }
    
    function updateAndSendControlString() {
        let str = "mac=asda;";
        const jn = ["X","Y","Z","p","y","r"];
        for (let i=0; i<6; i++) { str += `h1${jn[i]}=${robot1Joints[i] || 0};`; }
        for (let i=0; i<6; i++) { str += `h2${jn[i]}=${robot2Joints[i] || 0};`; }

        if (window.pywebview) {
            window.pywebview.api.get_latest_serial().then(res => {
                str += (res.serial || "") + ";";
                const iframe = document.querySelector("#centerPane iframe");
                if (iframe) iframe.contentWindow.postMessage({ controlString: str }, "*");
            });
        }
    }

    // --- Bottom Panel Toggle Functions ---
    function initializeBottomPanelToggle() {
        const toggleButton = document.getElementById('bottomToggleButton');
        const bottomContainer = document.getElementById('bottomContainer');
        
        toggleButton.addEventListener('click', () => {
            bottomPanelHidden = !bottomPanelHidden;
            bottomContainer.classList.toggle('hidden', bottomPanelHidden);
            
            if (bottomPanelHidden) {
                toggleButton.textContent = 'Show Bottom Panel';
            } else {
                toggleButton.textContent = 'Hide Bottom Panel';
                // Update Three.js renderers when showing - use multiple timeouts to ensure proper sizing
                setTimeout(onWindowResize, 50);
                setTimeout(onWindowResize, 200);
                setTimeout(onWindowResize, 500);
            }
        });
    }

    document.getElementById("zeroBtn1").addEventListener("click", () => {
        if(window.pywebview) window.pywebview.api.go_to_zero_robot1().then(res => handle_robot_update(1, res));
    });
    document.getElementById("zeroBtn2").addEventListener("click", () => {
        if(window.pywebview) window.pywebview.api.go_to_zero_robot2().then(res => handle_robot_update(2, res));
    });

    function onWindowResize(){
        const bottomContainer = document.getElementById('bottomContainer');
        
        // Only update Three.js renderers if bottom panel is not hidden
        if (!bottomContainer.classList.contains('hidden')) {
            // Force a layout recalculation
            bottomContainer.offsetHeight;
            
            let pane3 = document.getElementById("mainThreejsView").parentElement;
            if (pane3 && r1_view && r1_view.renderer) {
                r1_view.renderer.setSize(pane3.clientWidth, pane3.clientHeight);
                r1_view.camera.aspect = pane3.clientWidth / pane3.clientHeight;
                r1_view.camera.updateProjectionMatrix();
            }
            
            let pane1 = document.getElementById("secondView").parentElement;
            if (pane1 && r2_view && r2_view.renderer) {
                r2_view.renderer.setSize(pane1.clientWidth, pane1.clientHeight);
                const aspect = pane1.clientWidth / pane1.clientHeight;
                r2_view.camera.left = -0.12 * aspect; // Scaled from 120m to 0.12m (120mm)
                r2_view.camera.right = 0.12 * aspect; // Scaled from 120m to 0.12m (120mm)
                r2_view.camera.updateProjectionMatrix();
            }
        }
    }
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('pywebviewready', init);
  </script>
</body>
</html>